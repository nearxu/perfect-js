// http://www.cnblogs.com/onepixel/p/5090799.html

// JavaScript 是单线程语言。在浏览器中，当JS代码被加载时，浏览器会为其分配一个主线程来执行任务，主线程会在栈中创建一个全局执行环境 （全局作用域）。每当有一个函数进入执行流时，就会形成一个对应的执行环境（函数作用域），并将该执行环境压入栈中。每当一个函数执行完毕以后，对应的执行环境就会从栈中弹出，然后被销毁。这就是执行环境栈，执行环境栈的作用就是保证所有的函数能按照正确的顺序被执行。

// 但在浏览器中，有一些任务是非常耗时的，比如 ajax请求、定时器、事件等。为了保证主线程上的任务不被阻塞，JavaScript 内部维护了一个任务队列， 当这些耗时任务结束时（Ajax 请求返回、定时器超时、事件被触发），就将对应的回调函数插入队列中进行等待。这些任务的执行时机并不确定，只有当所有同步任务执行完毕后，执行环境栈被清空（栈底的全局执行环境会一直存在，直到进程退出）以后，然后再从任务队列中依次读取回调函数，并将其压入执行环境栈中。于是，主线程开始执行新的同步任务，执行完毕后再从栈中弹出，栈被清空。

// 主线程从任务队列中读取任务是不断循环的，每当栈被清空后，主线程就会从任务队列中读取新的任务并执行，如果没有新的任务，就会一直等待，直到有新的任务。JavaScript 的这种执行机制就叫做任务循环。因为每个任务都由一个事件所触发，所以也叫 “事件循环”。

var x = 1;
function A(y){
  var x = 2;
  function B(z){
    console.log(x+y+z);
  }
  return B;
}

var c = A(1);
console.log(c(1)); //全局初始化、执行函数A、执行函数B

// 1.全局初始化//创建一个全局对象
var globalObject = {
  Math:{},
  String:{},
  Date:{},
  document:{}, //DOM操作
  ...
  window:this //让window属性指向了自身
}

ECStack = [   //执行环境栈
  EC(G) = {   //全局执行环境
      VO(G):{ //定义全局变量对象
          ... //包含全局对象原有的属性
          x = 1; //定义变量x
          A = function(){...}; //定义函数A
          A[[scope]] = this; //定义A的scope，并赋值为VO本身
      }
  }
];

// 执行函数A
ECStack = [   //执行环境栈
  EC(A) = {   //A的执行环境
      [scope]:VO(G), //VO是全局变量对象
      AO(A) : { //创建函数A的活动对象
          y:1,
          x:2,  //定义局部变量x
          B:function(){...}, //定义函数B
          B[[scope]] = this; //this指代AO本身，而AO位于scopeChain的顶端，因此B[[scope]]指向整个作用域链
          arguments:[],//平时我们在函数中访问的arguments就是AO中的arguments
          this:window  //函数中的this指向调用者window对象
      },
      scopeChain:<AO(A),A[[scope]]>  //链表初始化为A[[scope]],然后再把AO加入该作用域链的顶端,此时A的作用域链：AO(A)->VO(G)
  },
  EC(G) = {   //全局执行环境
      VO(G):{ //创建全局变量对象
          ... //包含全局对象原有的属性
          x = 1; //定义变量x
          A = function(){...}; //定义函数A
          A[[scope]] = this; //定义A的scope，A[[scope]] == VO(G)
      }
  }
];